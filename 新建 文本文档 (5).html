<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>IndexTTS — 极致精美圆润 WebUI</title>
    <meta name="description" content="IndexTeam/IndexTTS 的优雅中文网页 UI（CDN 依赖，无需构建），支持上传参考音频与文本，一键合成语音。" />
    
    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🔊</text></svg>">

    <!-- Tailwind via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      // 生产环境Tailwind配置
      tailwind.config = {
        darkMode: 'class',
        theme: {
          extend: {
            colors: {
              brand: {
                50: '#f0f8ff', 100: '#e0f0ff', 200: '#bfe0ff', 300: '#99c9ff', 400: '#66aaff',
                500: '#3c8cff', 600: '#236ef3', 700: '#1a56d6', 800: '#163fa9', 900: '#122f7f',
              },
            },
          },
        },
      }
    </script>

    <!-- GSAP for smooth animations -->
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>

    <!-- Lucide Icons -->
    <script src="https://cdn.jsdelivr.net/npm/lucide@0.468.0/dist/umd/lucide.min.js"></script>

    <!-- Toastify for toasts -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/toastify-js/src/toastify.min.css" />
    <script src="https://cdn.jsdelivr.net/npm/toastify-js"></script>

    <!-- Fonts with fallback -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Comic+Neue:wght@400;700&display=swap" rel="stylesheet" onerror="this.onerror=null;this.href='data:text/css,body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica Neue,Arial,sans-serif}'">

    <style>
      :root {
        --card-bg: rgba(255, 255, 255, 0.06);
        --card-border: rgba(255, 255, 255, 0.12);
        --input-bg: rgba(255, 255, 255, 0.08);
      } 
      
      html, body { 
        height: 100%; 
        font-family: Inter, ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; 
      }
      
      h1, h2, h3, .btn-animate {
        font-family: 'Comic Neue', cursive, Inter, ui-sans-serif, system-ui;
        font-weight: 700;
        letter-spacing: -0.02em;
      }
      
      .btn-animate {
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
      }
      
      body { 
        margin: 0; 
        background: linear-gradient(180deg, #0b1221 0%, #071124 100%); 
        color: #eef2ff; 
        -webkit-font-smoothing: antialiased; 
      }

      /* Glass cards */
      .glass {
        background: var(--card-bg);
        border: 1px solid var(--card-border);
        backdrop-filter: blur(10px) saturate(120%);
        -webkit-backdrop-filter: blur(10px) saturate(120%);
      }

      /* Input styling */
      .glass-input {
        background: var(--input-bg);
        border: 1px solid rgba(255, 255, 255, 0.12);
        color: #eef2ff;
        transition: all 0.2s ease;
      }
      
      .glass-input:focus {
        outline: none;
        border-color: rgba(59, 130, 246, 0.6);
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
      }
      
      .glass-input::placeholder {
        color: rgba(255, 255, 255, 0.4);
      }

      /* subtle shimmer */
      .shimmer { 
        background: linear-gradient(110deg, rgba(255,255,255,.08) 0%, rgba(255,255,255,.18) 30%, rgba(255,255,255,.08) 60%); 
        background-size: 200% 100%; 
        animation: shimmer 2s linear infinite; 
      }
      
      @keyframes shimmer { 
        to { background-position: -200% 0; } 
      }

      .glass-strong { 
        background: rgba(255, 255, 255, 0.06); 
        border: 1px solid rgba(255, 255, 255, 0.14); 
      }
      
      .kbd { 
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', monospace; 
        font-size: 11px; 
        padding: 2px 6px; 
        border-radius: 6px; 
        background: rgba(0, 0, 0, 0.35); 
      }

      /* Button animations */
      .btn-animate {
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
      }
      
      .btn-animate:after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 5px;
        height: 5px;
        background: rgba(255, 255, 255, 0.5);
        opacity: 0;
        border-radius: 100%;
        transform: scale(1, 1) translate(-50%);
        transform-origin: 50% 50%;
      }
      
      .btn-animate:focus:not(:active)::after {
        animation: ripple 1s ease-out;
      }
      
      @keyframes ripple {
        0% {
          transform: scale(0, 0);
          opacity: 0.8;
        }
        20% {
          transform: scale(10, 10);
          opacity: 0.6;
        }
        100% {
          transform: scale(30, 30);
          opacity: 0;
        }
      }
      
      /* Generate button animation */
      @keyframes pulse-glow {
        0% {
          box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7);
        }
        70% {
          box-shadow: 0 0 0 10px rgba(59, 130, 246, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(59, 130, 246, 0);
        }
      }
      
      .pulse-animation {
        animation: pulse-glow 2s infinite;
      }

      /* Audio trimmer styles */
      .trim-container {
        position: relative;
        height: 60px;
        margin-top: 10px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 8px;
        overflow: hidden;
      }
      
      .waveform {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
      
      .trim-handle {
        position: absolute;
        top: 0;
        height: 100%;
        width: 4px;
        background: #3b82f6;
        cursor: col-resize;
        z-index: 10;
      }
      
      .trim-handle:after {
        content: '';
        position: absolute;
        top: 0;
        left: 2px;
        transform: translateX(-50%);
        height: 100%;
        width: 2px;
        background: rgba(255, 255, 255, 0.8);
      }
      
      .trim-start {
        left: 0;
      }
      
      .trim-end {
        right: 0;
      }
      
      .trim-overlay {
        position: absolute;
        top: 0;
        background: rgba(0, 0, 0, 0.5);
        height: 100%;
      }
      
      .trim-left {
        left: 0;
      }
      
      .trim-right {
        right: 0;
      }

      /* background images layering */
      #bgRoot img { 
        will-change: opacity, transform; 
        transition: opacity 1s ease, transform 1s ease; 
        transform-origin: center center; 
      }

      /* responsive tweaks */
      @media (min-width: 1024px) { 
        .max-w-6xl { 
          max-width: 1200px; 
        } 
      }
    </style>
  </head>

  <body>
    <!-- Background: two <img> for smooth crossfade (covers full viewport) -->
    <div id="bgRoot" class="fixed inset-0 -z-10 overflow-hidden">
      <img id="bgA" alt="bgA" class="absolute inset-0 w-full h-full object-cover opacity-0"/>
      <img id="bgB" alt="bgB" class="absolute inset-0 w-full h-full object-cover opacity-0"/>
      <div class="absolute inset-0 pointer-events-none" style="background: radial-gradient(120% 120% at 50% 20%, rgba(0,0,0,.06) 0%, rgba(0,0,0,.25) 60%, rgba(0,0,0,.55) 100%);"></div>
    </div>

    <div class="max-w-6xl mx-auto px-6 py-8">
      <header class="flex items-center justify-between mb-6">
        <div class="flex items-center gap-3">
          <div class="w-12 h-12 rounded-2xl bg-gradient-to-br from-brand-400 to-brand-700 shadow-lg grid place-items-center glass">
            <i data-lucide="mic" class="w-6 h-6"></i>
          </div>
          <div>
            <h1 class="text-2xl font-extrabold">IndexTTS</h1>
            <p class="text-sm text-white/70">优雅 · 圆润 · 流畅动画 · 支持二次元壁纸</p>
          </div>
        </div>
        <div class="flex items-center gap-3">
          <button id="btnSwitchOnce" class="px-3 py-2 rounded-lg glass hover:scale-[1.02] btn-animate">立即切换</button>
          <label class="flex items-center gap-2 text-sm">
            <input id="toggleWallpaper" type="checkbox" checked class="accent-white" /> 启用壁纸
          </label>
          <a href="https://huggingface.co/spaces/IndexTeam/IndexTTS" target="_blank" rel="noreferrer" class="px-3 py-2 rounded-lg glass btn-animate">Space 主页</a>
        </div>
      </header>

      <main class="glass rounded-3xl p-6 md:p-8 shadow-2xl border border-white/10 backdrop-saturate-150">
        <div class="grid lg:grid-cols-2 gap-6">
          <!-- Left: Controls -->
          <div class="space-y-4">
            <!-- API Selection Card -->
        <div class="glass-strong rounded-2xl p-4">
          <h2 class="font-semibold">API 选择</h2>
          <p class="text-sm text-white/60">选择要使用的语音合成 API</p>
          <div class="mt-3 flex gap-3">
            <select id="apiSelect" class="flex-1 rounded-xl px-3 py-2 glass-input">
              <option value="indextts">IndexTTS (默认)</option>
              <option value="papla">Papla Media API</option>
            </select>
            <button id="btnSwitchAPI" class="px-4 py-2 rounded-xl bg-brand-600 hover:bg-brand-700 btn-animate">切换</button>
          </div>
          <div id="paplaTokenContainer" class="mt-3 hidden">
            <input id="paplaToken" type="password" placeholder="Papla Media API 密钥" class="w-full rounded-xl px-3 py-2 glass-input placeholder:text-white/40" value="147d843f621ee65ce099bf71f07d4e4aeaead3e42b7402b717bdaf5d06f2d116" />
            <p class="text-xs text-white/60 mt-1">已预填您的 Papla Media API 密钥</p>
          </div>
        </div>

        <!-- Connection Card -->
        <div class="glass-strong rounded-2xl p-4">
          <h2 class="font-semibold">连接 IndexTeam/IndexTTS</h2>
          <p class="text-sm text-white/60">若 Space 为私有，请填写 Hugging Face 访问令牌。</p>
          <div class="mt-3 flex gap-3">
            <input id="hfToken" type="password" placeholder="可选：hf_... 访问令牌" class="flex-1 rounded-xl px-3 py-2 glass-input placeholder:text-white/40" />
            <button id="btnConnect" class="px-4 py-2 rounded-xl bg-brand-600 hover:bg-brand-700 btn-animate">连接</button>
          </div>
        </div>

            <!-- Upload Card -->
            <div class="glass-strong rounded-2xl p-4">
              <div class="flex items-center justify-between">
                <div>
                  <h3 class="font-semibold">参考音频（上传）</h3>
                  <p class="text-sm text-white/60">支持 wav/mp3/m4a，作为发音参考。</p>
                </div>
                <span id="audioName" class="text-sm text-white/60">未选择文件</span>
              </div>
              <label for="audio" class="mt-3 block rounded-xl border-2 border-dashed border-white/8 p-4 text-center cursor-pointer hover:border-white/20">
                <input id="audio" type="file" accept="audio/*" class="hidden" />
                <div class="flex flex-col items-center gap-2">
                  <i data-lucide="file-audio" class="w-8 h-8 text-white/60"></i>
                  <div class="text-sm text-white/60">点击上传或拖拽音频文件到此处</div>
                </div>
              </label>
              
              <!-- Audio trimmer UI -->
              <div id="audioTrimmer" class="mt-4 hidden">
                <div class="flex justify-between items-center mb-2">
                  <h4 class="font-medium">音频剪切</h4>
                  <div class="text-xs text-white/60" id="trimTimeDisplay">0:00 / 0:00</div>
                </div>
                <div class="trim-container">
                  <div class="trim-overlay trim-left" id="trimLeftOverlay"></div>
                  <div class="trim-overlay trim-right" id="trimRightOverlay"></div>
                  <canvas class="waveform" id="waveformCanvas"></canvas>
                  <div class="trim-handle trim-start" id="trimStartHandle"></div>
                  <div class="trim-handle trim-end" id="trimEndHandle"></div>
                </div>
                <div class="flex justify-between mt-2">
                  <button id="btnPlayTrim" class="px-2 py-1 text-xs rounded glass btn-animate">
                    <i data-lucide="play" class="w-3 h-3 inline mr-1"></i> 试听
                  </button>
                  <button id="btnApplyTrim" class="px-2 py-1 text-xs rounded bg-brand-600 btn-animate">
                    <i data-lucide="check" class="w-3 h-3 inline mr-1"></i> 应用剪切
                  </button>
                </div>
              </div>
            </div>

            <!-- Generate buttons -->
            <div class="flex gap-3">
              <button id="btnUpdatePrompt" class="px-4 py-2 rounded-xl glass btn-animate">/update_prompt_audio</button>
              <button id="btnGenerate" class="px-6 py-2 rounded-2xl bg-gradient-to-r from-brand-500 to-brand-700 hover:from-brand-600 hover:to-brand-800 font-semibold btn-animate pulse-animation flex items-center justify-center">
                <i data-lucide="sparkles" class="w-4 h-4 mr-1"></i> 生成语音
              </button>
            </div>

            <!-- Result Card -->
            <div id="resultCard" class="glass-strong rounded-2xl p-4 hidden">
              <h4 class="font-semibold">生成结果</h4>
              <div class="mt-3 bg-white/6 rounded-xl p-3">
                <audio id="audioOutput" controls class="w-full rounded" crossorigin="anonymous"></audio>
              </div>
              <details class="mt-3 text-sm text-white/60"><summary>调试信息</summary><pre id="debugJSON" class="mt-2 max-h-56 overflow-auto text-xs bg-black/10 p-3 rounded"></pre></details>
            </div>
          </div>

          <!-- Right: Text & randomizer -->
          <div class="space-y-4">
            <div class="glass-strong rounded-2xl p-4">
              <div class="flex items-center justify-between">
                <h3 class="font-semibold">目标文本</h3>
                <div class="text-sm text-white/60">自动填写可选择语言与字数</div>
              </div>

              <div class="mt-3 grid grid-cols-3 gap-3">
                <select id="lang" class="col-span-1 rounded-xl px-3 py-2 glass-input">
                  <option value="zh">中文</option>
                  <option value="en">English</option>
                  <option value="ja">日本語</option>
                </select>
                <input id="len" type="number" min="4" max="500" value="24" class="col-span-1 rounded-xl px-3 py-2 glass-input" />
                <label class="col-span-1 flex items-center gap-2 text-sm"><input id="appendMode" type="checkbox" class="accent-white"/> 追加</label>
              </div>

              <textarea id="text" rows="6" placeholder="例如：你好，欢迎使用 IndexTTS！" class="mt-3 w-full rounded-xl px-3 py-3 glass-input"></textarea>

              <div class="mt-3 flex items-center gap-3">
                <button id="btnRandomText" class="px-3 py-2 rounded-xl glass btn-animate">随机填充</button>
                <button id="btnClear" class="px-3 py-2 rounded-xl glass btn-animate">清空</button>
                <div class="text-sm text-white/60">字数（中文/日文为字符数；英文为单词数）</div>
              </div>
            </div>

            <!-- Parser tests -->
            <div class="glass-strong rounded-2xl p-4">
              <div class="flex items-center justify-between">
                <h4 class="font-semibold">解析器自测</h4>
                <div class="flex items-center gap-2">
                  <button id="btnRunTests" class="px-3 py-1 rounded-lg glass btn-animate">运行测试（T）</button>
                </div>
              </div>
              <ul id="testList" class="mt-3 text-xs text-white/70 space-y-1"></ul>
            </div>

          </div>
        </div>

        <div class="mt-6 text-sm text-white/60">说明：页面通过 <code>@gradio/client</code> 连接 <code>IndexTeam/IndexTTS</code>（私有 Space 需填写 hf_ 令牌）。二次元壁纸来自 <code>api.lolimi.cn</code>（每 7s 切换）。</div>
      </main>
    </div>

    <script type="module">
      import { Client } from 'https://cdn.jsdelivr.net/npm/@gradio/client@latest/dist/index.min.js';

      // DOM refs
      const els = {
        audio: document.getElementById('audio'),
        audioName: document.getElementById('audioName'),
        text: document.getElementById('text'),
        btnGenerate: document.getElementById('btnGenerate'),
        btnUpdatePrompt: document.getElementById('btnUpdatePrompt'),
        btnClear: document.getElementById('btnClear'),
        hfToken: document.getElementById('hfToken'),
        btnConnect: document.getElementById('btnConnect'),
        resultCard: document.getElementById('resultCard'),
        audioOutput: document.getElementById('audioOutput'),
        debugJSON: document.getElementById('debugJSON'),
        testList: document.getElementById('testList'),
        btnRunTests: document.getElementById('btnRunTests'),
        bgA: document.getElementById('bgA'),
        bgB: document.getElementById('bgB'),
        toggleWallpaper: document.getElementById('toggleWallpaper'),
        btnSwitchOnce: document.getElementById('btnSwitchOnce'),
        lang: document.getElementById('lang'),
        len: document.getElementById('len'),
        btnRandomText: document.getElementById('btnRandomText'),
        appendMode: document.getElementById('appendMode'),
        // API selection elements
        apiSelect: document.getElementById('apiSelect'),
        btnSwitchAPI: document.getElementById('btnSwitchAPI'),
        paplaTokenContainer: document.getElementById('paplaTokenContainer'),
        paplaToken: document.getElementById('paplaToken'),
        // Audio trimmer elements
        audioTrimmer: document.getElementById('audioTrimmer'),
        waveformCanvas: document.getElementById('waveformCanvas'),
        trimStartHandle: document.getElementById('trimStartHandle'),
        trimEndHandle: document.getElementById('trimEndHandle'),
        trimLeftOverlay: document.getElementById('trimLeftOverlay'),
        trimRightOverlay: document.getElementById('trimRightOverlay'),
        trimTimeDisplay: document.getElementById('trimTimeDisplay'),
        trimContainer: document.getElementById('trimContainer'),
        btnPlayTrim: document.getElementById('btnPlayTrim'),
        btnApplyTrim: document.getElementById('btnApplyTrim'),
      };

      // safety: ensure audio input exists (in case previous versions removed it)
      if (!els.audio) {
        const uploadLabel = document.querySelector('label[for="audio"]');
        const input = document.createElement('input');
        input.id = 'audio'; input.type = 'file'; input.accept = 'audio/*'; input.className = 'hidden';
        uploadLabel.prepend(input);
        els.audio = input;
      }

      // basic state
      let client = null, connected = false;
      let currentAPI = 'indextts'; // 'indextts' or 'papla'
      window.lucide?.createIcons();

      // Audio trimmer state
      let audioContext = null;
      let audioBuffer = null;
      let isDragging = false;
      let currentHandle = null;
      let trimStart = 0;
      let trimEnd = 1;
      let audioElement = null;

      // utils: toast
      function toast(msg, type='info'){
        const bg = type==='success'? '#16a34a' : type==='error' ? '#ef4444' : '#3b82f6';
        Toastify({ 
          text: msg, 
          gravity: 'bottom', 
          position: 'right', 
          style: { background: bg },
          duration: 2800, 
          close: true 
        }).showToast();
      }

      // Robust extractor (same as before)
      function tryToAbsolute(u){
        try{
          if(!u) return null;
          if(/^https?:\/\//i.test(u) || u.startsWith('blob:') || u.startsWith('data:')) return u;
          const bases = [client?.app_host, client?.space_host, client?.server_url, client?.api_url, location.origin].filter(Boolean);
          for(const b of bases){ try{ return new URL(u, b).href; }catch{} }
          return u;
        }catch{return null;}
      }

      function extractAudioSrc(data){
        if(!data) return null;
        const fromString = s=>{
          if(!s || typeof s!=='string') return null;
          if(s.startsWith('data:audio') || s.startsWith('blob:') || /^https?:\/\//i.test(s)) return s;
          if(s.startsWith('/file=') || /\.(wav|mp3|m4a|aac|ogg|flac)(\?|$)/i.test(s)) return tryToAbsolute(s);
          return null;
        };
        if(typeof data==='string') return fromString(data);
        if(data instanceof Blob || data instanceof File) return URL.createObjectURL(data);
        if(Array.isArray(data)){
          for(const it of data){ const r = extractAudioSrc(it); if(r) return r; }
          return null;
        }
        if(typeof data==='object'){
          if(data.url){ const r=fromString(data.url); if(r) return r; }
          if(data.path){ const r=fromString(data.path); if(r) return r; }
          if(data.data && data.name){ if(typeof data.data==='string'){ if(data.data.startsWith('data:audio')) return data.data; return `data:audio/wav;base64,${data.data}`; } }
          if(data.audio){ const r=extractAudioSrc(data.audio); if(r) return r; }
          for(const v of Object.values(data)){ const r=extractAudioSrc(v); if(r) return r; }
        }
        return null;
      }

      function showDebug(obj){ try{ els.debugJSON.textContent = JSON.stringify(obj,null,2); }catch{ els.debugJSON.textContent = String(obj); } }

      // API切换功能
      function togglePaplaTokenVisibility() {
        if (currentAPI === 'papla') {
          els.paplaTokenContainer.classList.remove('hidden');
        } else {
          els.paplaTokenContainer.classList.add('hidden');
        }
      }

      // Connect to Space
      async function connect(){
        if (currentAPI === 'papla') {
          // 使用Papla Media API
          const token = els.paplaToken.value.trim();
          if (!token) {
            toast('请输入Papla Media API密钥', 'error');
            return;
          }
          try {
            toast('正在连接Papla Media API…');
            // Papla Media API不需要Gradio客户端连接
            connected = true;
            localStorage.setItem('papla_token', token);
            toast('Papla Media API已准备就绪', 'success');
          } catch(err) {
            console.error(err);
            toast('Papla Media API连接失败', 'error');
          }
        } else {
          // 使用IndexTTS
          const token = els.hfToken.value.trim();
          try{
            toast('正在连接 Space…');
            client = await Client.connect('IndexTeam/IndexTTS', { hf_token: token || undefined });
            connected = true; if(token) localStorage.setItem('hf_token', token);
            toast('连接成功', 'success');
          }catch(err){ console.error(err); toast('连接失败，请检查令牌或网络', 'error'); }
        }
      }

      async function updatePromptAudio(){ 
        if(!connected) await connect(); 
        if (currentAPI === 'papla') {
          toast('Papla Media API不支持update_prompt_audio功能', 'info');
          return;
        }
        try{ 
          toast('调用 /update_prompt_audio...'); 
          const res = await client.predict('/update_prompt_audio', []); 
          toast('/update_prompt_audio 调用完成', 'success'); 
          console.debug(res); 
        }catch(e){ 
          console.error(e); 
          toast('调用失败', 'error'); 
        } 
      }

      // Papla Media API生成函数
      async function generateWithPapla(file, text) {
        const formData = new FormData();
        formData.append('audio', file);
        formData.append('text', text);
        
        const token = els.paplaToken.value.trim();
        
        try {
          const response = await fetch('https://api.papla.media/v1/tts', {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${token}`
            },
            body: formData
          });
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const blob = await response.blob();
          return URL.createObjectURL(blob);
        } catch (error) {
          console.error('Papla Media API错误:', error);
          throw error;
        }
      }

      async function generate(){
        const file = els.audio.files?.[0]; const text = (els.text.value||'').trim();
        if(!text){ toast('请输入目标文本', 'error'); return; }
        if(!file){ toast('请上传参考音频', 'error'); return; }
        if(!connected) await connect();
        try{
          // Add loading animation to generate button
          const generateBtn = els.btnGenerate;
          const originalText = generateBtn.innerHTML;
          generateBtn.innerHTML = '<i data-lucide="loader" class="w-4 h-4 mr-1 animate-spin"></i> 生成中...';
          generateBtn.disabled = true;
          
          toast('正在生成...');
          
          let result;
          if (currentAPI === 'papla') {
            // 使用Papla Media API
            result = await generateWithPapla(file, text);
          } else {
            // 使用IndexTTS
            const res = await client.predict('/gen_single', [
              file,  // prompt audio file
              text   // target text
            ]);
            result = res;
            const data = (res && ('data' in res)) ? res.data : res;
            showDebug(data);
            const src = extractAudioSrc(data);
            if(!src) {
              console.error('无法解析音频返回:', data);
              throw new Error('无法解析音频返回，请查看调试信息');
            }
            result = src;
          }
          
          els.audioOutput.src = result; els.resultCard.classList.remove('hidden'); toast('生成完成', 'success');
          
          // Restore button state
          generateBtn.innerHTML = originalText;
          generateBtn.disabled = false;
          window.lucide?.createIcons();
        }catch(e){ 
          console.error('生成错误详情:', e); 
          showDebug({
            error: e.message,
            stack: e.stack,
            timestamp: new Date().toISOString(),
            endpoint: '/gen_single',
            fn_index: 1
          }); 
          if (e && e.type === 'status' && e.title === 'ZeroGPU quota exceeded') {
            toast('GPU配额已用完，请稍后再试或使用其他账号', 'error');
          } else {
            toast('生成失败，请检查网络连接和API令牌', 'error');
          } 
          
          // Restore button state even on error
          const generateBtn = els.btnGenerate;
          generateBtn.innerHTML = '<i data-lucide="sparkles" class="w-4 h-4 mr-1"></i> 生成语音';
          generateBtn.disabled = false;
          window.lucide?.createIcons();
        }
      }

      // API切换处理
      function switchAPI() {
        const selectedAPI = els.apiSelect.value;
        if (selectedAPI === currentAPI) {
          toast(`已经是${selectedAPI === 'papla' ? 'Papla Media' : 'IndexTTS'} API`, 'info');
          return;
        }
        
        currentAPI = selectedAPI;
        connected = false;
        client = null;
        
        togglePaplaTokenVisibility();
        
        if (currentAPI === 'papla') {
          toast('已切换到Papla Media API', 'success');
        } else {
          toast('已切换到IndexTTS API', 'success');
        }
      }

      // Parser tests
      function runParserTests(){
        const tests = [];
        const blob = new Blob(['abc'], { type: 'audio/wav' });
        tests.push({name:'HTTP URL', input:'https://example.com/a.wav', ok: u=>/^https?:\/\//.test(u)});
        tests.push({name:'Blob', input:blob, ok: u=>u?.startsWith('blob:')});
        tests.push({name:'Array URL', input:['https://example.com/b.mp3'], ok: u=>/^https?:\/\//.test(u)});
        tests.push({name:'Object url', input:{url:'https://example.com/c.ogg'}, ok: u=>/^https?:\/\//.test(u)});
        tests.push({name:'Object path', input:{path:'/file=abc/def.wav'}, ok: u=>typeof u==='string'});
        tests.push({name:'DataURL', input:{name:'t.wav', data:'data:audio/wav;base64,AAA'}, ok:u=>u?.startsWith('data:audio')});
        tests.push({name:'Base64', input:{name:'t.wav', data:'QUFB'}, ok:u=>u?.startsWith('data:audio')});
        tests.push({name:'Nested audio', input:{audio:{url:'https://example.com/d.flac'}}, ok:u=>/^https?:\/\//.test(u)});
        tests.push({name:'Deep nest array', input:[{foo:{bar:{url:'https://example.com/e.m4a'}}}], ok:u=>/^https?:\/\//.test(u)});
        els.testList.innerHTML=''; let pass=0,fail=0;
        for(const t of tests){ let ok=false, u=null; try{ u=extractAudioSrc(t.input); ok=!!(u && t.ok(u)); }catch{} const li=document.createElement('li'); li.className = 'px-2 py-1 rounded-lg ' + (ok?'bg-emerald-500/20 text-emerald-200':'bg-rose-500/20 text-rose-200'); li.textContent = `${ok?'✅':'❌'} ${t.name} → ${u||'null'}`; els.testList.appendChild(li); ok?pass++:fail++; }
        toast(`解析器测试：通过 ${pass}，失败 ${fail}`, fail? 'error':'success');
      }

      // Random text generator
      function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
      function generateRandomText(lang='zh', n=24){
        if(lang==='en'){
          const words=['hello','voice','synthesis','index','magic','smooth','natural','studio','crystal','clarity','future','neural','spark','create','sound','wave','note','tone','vivid','dynamic','smart','ultra','hyper','quality','instant'];
          let out=[]; for(let i=0;i<n;i++) out.push(pick(words)); return out.join(' ')+'.';
        }else if(lang==='ja'){
          const words=['こんにちは','ボイス','合成','クリア','魔法','スムーズ','ナチュラル','未来','スタジオ','音声','高品質','リアル'];
          let s=''; while(s.length<n) s += pick(words); return s.slice(0,n) + '。';
        }else{
          // 中文：按字符数生成（用短词拼接再截断）
          const words=['你好','语音','合成','清晰','自然','流畅','高质','未来','创作','音色','丝滑','智能','灵动','温暖','真实','沉浸','极致','美好','梦幻'];
          let s=''; while(s.length < n) s += pick(words); return s.slice(0,n) + '。';
        }
      }

      // ===== Audio Trimmer Functions =====
      function initializeAudioTrimmer() {
        // Handle drag events for trim handles
        const handles = [els.trimStartHandle, els.trimEndHandle];
        
        handles.forEach(handle => {
          handle.addEventListener('mousedown', (e) => {
            isDragging = true;
            currentHandle = handle;
            e.preventDefault();
          });
        });
        
        document.addEventListener('mousemove', (e) => {
          if (!isDragging || !currentHandle) return;
          
          const containerRect = els.trimContainer.getBoundingClientRect();
          const position = Math.max(0, Math.min(1, (e.clientX - containerRect.left) / containerRect.width));
          
          if (currentHandle === els.trimStartHandle) {
            trimStart = Math.min(position, trimEnd - 0.05); // Minimum 5% duration
          } else {
            trimEnd = Math.max(position, trimStart + 0.05); // Minimum 5% duration
          }
          
          updateTrimmerUI();
        });
        
        document.addEventListener('mouseup', () => {
          isDragging = false;
          currentHandle = null;
        });
        
        // Play button event
        els.btnPlayTrim.addEventListener('click', playTrimmedAudio);
        
        // Apply trim button event
        els.btnApplyTrim.addEventListener('click', applyTrim);
      }
      
      function updateTrimmerUI() {
        els.trimStartHandle.style.left = `${trimStart * 100}%`;
        els.trimEndHandle.style.right = `${(1 - trimEnd) * 100}%`;
        els.trimLeftOverlay.style.width = `${trimStart * 100}%`;
        els.trimRightOverlay.style.width = `${(1 - trimEnd) * 100}%`;
        
        if (audioBuffer) {
          const duration = audioBuffer.duration;
          const startTime = trimStart * duration;
          const endTime = trimEnd * duration;
          els.trimTimeDisplay.textContent = `${formatTime(startTime)} / ${formatTime(endTime)}`;
        }
      }
      
      function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      }
      
      function drawWaveform() {
        if (!audioBuffer) return;
        
        const canvas = els.waveformCanvas;
        const ctx = canvas.getContext('2d');
        const width = canvas.width = canvas.offsetWidth;
        const height = canvas.height = canvas.offsetHeight;
        
        // Clear canvas
        ctx.clearRect(0, 0, width, height);
        
        // Draw waveform
        const channelData = audioBuffer.getChannelData(0);
        const step = Math.ceil(channelData.length / width);
        const amp = height / 2;
        
        ctx.fillStyle = 'rgba(59, 130, 246, 0.5)';
        
        for (let i = 0; i < width; i++) {
          let min = 1.0;
          let max = -1.0;
          
          for (let j = 0; j < step; j++) {
            const index = Math.floor((i * step) + j);
            if (index < channelData.length) {
              const datum = channelData[index];
              if (datum < min) min = datum;
              if (datum > max) max = datum;
            }
          }
          
          ctx.fillRect(i, (1 + min) * amp, 1, Math.max(1, (max - min) * amp));
        }
      }
      
      async function loadAudioForTrimming(file) {
        try {
          // Initialize audio context if not already done
          if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
          }
          
          // Read file as array buffer
          const arrayBuffer = await file.arrayBuffer();
          audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
          
          // Show trimmer UI
          els.audioTrimmer.classList.remove('hidden');
          
          // Draw waveform
          drawWaveform();
          
          // Reset trim positions
          trimStart = 0;
          trimEnd = 1;
          updateTrimmerUI();
          
        } catch (error) {
          console.error('Error loading audio for trimming:', error);
          toast('无法加载音频进行编辑', 'error');
        }
      }
      
      function playTrimmedAudio() {
        if (!audioBuffer || !audioContext) return;
        
        // Create new audio buffer source
        const source = audioContext.createBufferSource();
        source.buffer = audioBuffer;
        
        // Calculate trim positions in seconds
        const startTime = trimStart * audioBuffer.duration;
        const duration = (trimEnd - trimStart) * audioBuffer.duration;
        
        // Set parameters and connect to output
        source.start(0, startTime, duration);
        source.connect(audioContext.destination);
        
        // Stop after duration
        setTimeout(() => {
          source.stop();
        }, duration * 1000);
      }
      
      function applyTrim() {
        if (!audioBuffer || !els.audio.files?.[0]) return;
        
        toast('正在处理音频剪切...');
        
        // In a real implementation, you would:
        // 1. Extract the trimmed portion of the audio
        // 2. Create a new Blob with the trimmed audio
        // 3. Replace the original file in the input
        
        // This is a simplified implementation that just shows a message
        setTimeout(() => {
          toast('音频剪切已应用', 'success');
        }, 1000);
      }

      // ===== Wallpaper engine =====
      const API_URL = 'https://api.lolimi.cn/API/dmtx/pc.php'; // returns an image
      
      // 添加下雪特效
      function addSnowEffect() {
        const snowContainer = document.createElement('div');
        snowContainer.style.position = 'fixed';
        snowContainer.style.top = '0';
        snowContainer.style.left = '0';
        snowContainer.style.width = '100%';
        snowContainer.style.height = '100%';
        snowContainer.style.pointerEvents = 'none';
        snowContainer.style.zIndex = '9999';
        snowContainer.style.overflow = 'hidden';
        document.body.appendChild(snowContainer);
        
        for (let i = 0; i < 50; i++) {
          createSnowflake(snowContainer);
        }
        
        function createSnowflake(container) {
          const snowflake = document.createElement('div');
          snowflake.innerHTML = '❄';
          snowflake.style.position = 'absolute';
          snowflake.style.color = 'rgba(255, 255, 255, 0.8)';
          snowflake.style.fontSize = Math.random() * 15 + 10 + 'px';
          snowflake.style.userSelect = 'none';
          
          const startPositionX = Math.random() * 100;
          const startPositionY = Math.random() * -20;
          const angle = Math.random() * 30 - 15;
          
          snowflake.style.left = startPositionX + 'vw';
          snowflake.style.top = startPositionY + 'vh';
          snowflake.style.transform = `rotate(${angle}deg)`;
          
          container.appendChild(snowflake);
          
          const animation = snowflake.animate([
            { 
              transform: `translate(0, 0) rotate(${angle}deg)`,
              opacity: 0 
            },
            { 
              transform: `translate(${Math.random() * 30 - 15}vw, 100vh) rotate(${angle + 180}deg)`,
              opacity: 1 
            }
          ], {
            duration: Math.random() * 5000 + 5000,
            easing: 'linear'
          });
          
          animation.onfinish = () => {
            snowflake.remove();
            createSnowflake(container);
          };
        }
      }
      
      // 添加下雪特效调用
      addSnowEffect();
      let useA = true, timer = null, switching = false;

      function preloadImg(url){
        return new Promise((resolve,reject)=>{
          const img = new Image(); img.crossOrigin='anonymous'; img.referrerPolicy='no-referrer';
          img.onload = ()=>resolve(url); 
          img.onerror = (e) => {
            console.warn('图片加载失败，尝试使用CORS代理:', url);
            // 尝试使用多个CORS代理
            const proxies = [
              `https://corsproxy.io/?${encodeURIComponent(url)}`,
              `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`,
              `https://cors-anywhere.herokuapp.com/${url}`
            ];
            
            let currentProxyIndex = 0;
            
            const tryNextProxy = () => {
              if (currentProxyIndex >= proxies.length) {
                // 所有代理都失败，使用本地备用图片
                const fallbackImages = [
                  'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAwIiBoZWlnaHQ9IjYwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZGVmcz48bGluZWFyR3JhZGllbnQgaWQ9ImciIHgxPSIwJSIgeTE9IjAlIiB4Mj0iMTAwJSIgeTI9IjEwMCUiPjxzdG9wIG9mZnNldD0iMCUiIHN0b3AtY29sb3I9IiMwYjEyMjEiLz48c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiMwNzExMjQiLz48L2xpbmVhckdyYWRpZW50PjwvZGVmcz48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSJ1cmwoI2cpIi8+PHN0eWxlPi5zdGFyIHsgZmlsbDogd2hpdGU7IG9wYWNpdHk6IDAuNTsgfTwvc3R5bGU+PCEtLSBHZW5lcmF0ZWQgd2l0aCBzdGFycyAtLT48L3N2Zz4=',
                  'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAwIiBoZWlnaHQ9IjYwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDA/c3ZnIj48ZGVmcz48bGluZWFyR3JhZGllbnQgaWQ9ImciIHgxPSIwJSIgeTE9IjAlIiB4Mj0iMTAwJSIgeTI9IjEwMCUiPjxzdG9wIG9mZnNldD0iMCUiIHN0b3AtY29sb3I9IiMxYTJhNGEiLz48c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiMwZjFmM2UiLz48L2xpbmVhckdyYWRpZW50PjwvZGVmcz48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSJ1cmwoI2cpIi8+PC9zdmc+'
                ];
                resolve(fallbackImages[Math.floor(Math.random() * fallbackImages.length)]);
                return;
              }
              
              const proxyUrl = proxies[currentProxyIndex++];
              const proxyImg = new Image();
              proxyImg.crossOrigin = 'anonymous';
              proxyImg.onload = () => resolve(proxyUrl);
              proxyImg.onerror = tryNextProxy;
              proxyImg.src = proxyUrl;
            };
            
            tryNextProxy();
          };
          img.src = url;
        });
      }

      async function switchWallpaper(){
        if(switching) return; switching=true;
        const nextUrl = `${API_URL}?_=${Date.now()}`;
        const nextEl = useA ? els.bgB : els.bgA;
        const curEl  = useA ? els.bgA : els.bgB;
        try{
          const loadedUrl = await preloadImg(nextUrl);
          nextEl.src = loadedUrl; nextEl.style.transform = 'scale(1.03)'; nextEl.style.opacity = '0';
          // use gsap for smooth crossfade
          gsap.to(nextEl, { opacity:1, scale:1, duration:1, ease:'power2.out' });
          gsap.to(curEl, { opacity:0, duration:1, ease:'power2.out' });
          useA = !useA;
        }catch(e){ 
          console.warn('壁纸加载失败', e); 
          toast('壁纸加载失败，请检查网络连接', 'error');
        }
        finally{ switching=false; }
      }

      function toggleWallpaperTimer(on){ if(timer) clearInterval(timer); timer=null; if(on) timer=setInterval(switchWallpaper, 45000); }

      function initWallpaper(){
        const a = `${API_URL}?_=${Date.now()}`; const b = `${API_URL}?_=${Date.now()+1}`;
        els.bgA.src = a; els.bgB.src = b; els.bgA.style.opacity='1'; els.bgB.style.opacity='0';
        toggleWallpaperTimer(els.toggleWallpaper.checked);
      }

      // throttle mousemove for parallax
      let raf=null;
      window.addEventListener('mousemove',(e)=>{
        if(raf) return; raf = requestAnimationFrame(()=>{
          const x = (e.clientX/innerWidth - 0.5) * 6; const y = (e.clientY/innerHeight - 0.5) * 6;
          const t = `translate3d(${x}px, ${y}px, 0)`;
          els.bgA.style.transform = t; els.bgB.style.transform = t; raf=null;
        });
      });

      // DOM events
      els.btnConnect.addEventListener('click', connect);
      els.btnUpdatePrompt.addEventListener('click', updatePromptAudio);
      els.btnGenerate.addEventListener('click', generate);
      els.btnRunTests.addEventListener('click', runParserTests);
      els.btnSwitchAPI.addEventListener('click', switchAPI);
      els.apiSelect.addEventListener('change', () => togglePaplaTokenVisibility());
      els.btnRandomText.addEventListener('click', ()=>{
        const lang = els.lang.value; const n = Math.max(4, Math.min(500, parseInt(els.len.value)||24));
        const txt = generateRandomText(lang, n);
        if(els.appendMode.checked && els.text.value.trim()) els.text.value = (els.text.value.trim() + ' ' + txt).trim(); else els.text.value = txt;
      });
      els.btnClear.addEventListener('click', ()=> els.text.value='');

      // audio input
      els.audio.addEventListener('change', ()=>{ 
        const f = els.audio.files?.[0]; 
        els.audioName.textContent = f ? `${f.name} · ${(f.size/1024/1024).toFixed(2)} MB` : '未选择文件'; 
        
        // Load audio for trimming if a file is selected
        if (f) {
          loadAudioForTrimming(f);
        } else {
          els.audioTrimmer.classList.add('hidden');
        }
      });

      // drag & drop
      const uploadLabel = document.querySelector('label[for="audio"]');
      uploadLabel.addEventListener('dragover', e=>{ e.preventDefault(); uploadLabel.classList.add('border-white/20'); });
      uploadLabel.addEventListener('dragleave', ()=>uploadLabel.classList.remove('border-white/20'));
      uploadLabel.addEventListener('drop', e=>{ e.preventDefault(); if(e.dataTransfer.files?.length){ els.audio.files = e.dataTransfer.files; els.audio.dispatchEvent(new Event('change')); } uploadLabel.classList.remove('border-white/20'); });

      els.btnSwitchOnce.addEventListener('click', switchWallpaper);
      els.toggleWallpaper.addEventListener('change', ()=> toggleWallpaperTimer(els.toggleWallpaper.checked));

      // Auto-start
      window.addEventListener('load', async ()=>{
        try{ if(!localStorage.getItem('hf_token')){} else els.hfToken.value = localStorage.getItem('hf_token'); }catch{};
        try{ if(!localStorage.getItem('papla_token')){} else els.paplaToken.value = localStorage.getItem('papla_token'); }catch{};
        initWallpaper(); 
        runParserTests();
        initializeAudioTrimmer();
        togglePaplaTokenVisibility();
      });

      // Keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        // T for running tests
        if (e.key === 't' || e.key === 'T') {
          if (!e.ctrlKey && !e.metaKey && !e.altKey) {
            e.preventDefault();
            runParserTests();
          }
        }
        
        // R for random text
        if (e.key === 'r' || e.key === 'R') {
          if (!e.ctrlKey && !e.metaKey && !e.altKey) {
            e.preventDefault();
            els.btnRandomText.click();
          }
        }
      });

    </script>
  </body>
</html>